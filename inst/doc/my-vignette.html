<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Split the Dataset</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>Here, we illustrate the <code>DevTreatRules</code> package by building and evaluating treatment rules based on the example dataset included with the package.</p>

<pre><code class="r">library(DevTreatRules)
head(obsStudyGeneExpressions)
##   no_relapse intervention prognosis clinic age gene_1 gene_2 gene_3 gene_4
## 1          1            0      Good      1  46  0.531  0.071 0.1294  0.427
## 2          0            1      Poor      3  51  0.744  0.711 1.3532  1.939
## 3          1            0      Poor      3  62  1.146  0.498 1.4707  1.456
## 4          1            0      Good      5  51  1.816  1.758 0.2226  0.688
## 5          1            1      Good      4  52  0.403  0.636 0.0933  0.288
## 6          1            1      Poor      6  51  1.797  0.642 0.2618  0.277
##   gene_5 gene_6 gene_7 gene_8 gene_9 gene_10
## 1  0.421  0.402  0.831 0.0136  1.186  1.8831
## 2  0.230  0.228  0.282 1.3413  1.106  0.6606
## 3  0.291  0.543  0.915 0.4839  1.193  0.6233
## 4  0.620  1.571  1.606 1.9986  0.785  1.7684
## 5  0.300  1.276  0.642 1.9003  0.521  0.0126
## 6  1.053  0.939  1.736 0.2348  1.480  1.3908
</code></pre>

<h2>Split the Dataset</h2>

<p>First, we split <code>obsStudyGeneExpressions</code> into independent development/validation/evaluation partitions by calling the <code>SplitData()</code> function</p>

<pre><code class="r">set.seed(123)
example.split &lt;- SplitData(data=obsStudyGeneExpressions, n.sets=3, split.proportions=c(0.5, 0.25, 0.25))
table(example.split$partition)
## 
## development  validation  evaluation 
##        2500        1250        1250
</code></pre>

<p>and then forming independent datasets based on the <code>partition</code> variable created above.</p>

<pre><code class="r">library(dplyr)
development.data &lt;- example.split %&gt;% filter(partition == &quot;development&quot;)
validation.data &lt;-  example.split %&gt;% filter(partition == &quot;validation&quot;)
evaluation.data &lt;-  example.split %&gt;% filter(partition == &quot;evaluation&quot;)
</code></pre>

<h2>Specify Variable Roles</h2>

<p>Suppose we believe the variables <code>prognosis</code>, <code>clinic</code>, and <code>age</code> may have influenced treatment assignment. We would codify this knowledge into <code>DevTreatRules</code> by specifying the argument</p>

<pre><code class="r">names.influencing.treatment=c(&quot;prognosis&quot;, &quot;clinic&quot;, &quot;age&quot;)
</code></pre>

<p>in functions we will call later in this vignette. Further suppose that we don&#39;t expect <code>prognosis</code> and <code>clinic</code> to be measured on the same scale in independent clinical settings where we would like to apply our estimated rule (so they are not sensible rule inputs). However, we do expect the gene expression measurements in <code>gene_1</code>, &hellip;, <code>gene_10</code> to potentially influence treatment response and also to be reliably measured in future settings (so they are sensible rule inputs). We specify this knowledge in <code>DevTreatRules</code> with the argument</p>

<pre><code class="r">names.influencing.rule=c(&quot;age&quot;, paste0(&quot;gene_&quot;, 1:10))
</code></pre>

<h2>On the Development Dataset, Build the Treatment Rule</h2>

<p>Although we could directly estimate a single treatment rule on the development dataset with <code>BuildRule()</code> using, for example,</p>

<pre><code class="r">one.rule &lt;- BuildRule(development.data=development.data,
                      study.design=&quot;observational&quot;,
                      prediction.approach=&quot;split.regression&quot;,
                      name.outcome=&quot;no_relapse&quot;,
                      type.outcome=&quot;binary&quot;,
                      desirable.outcome=TRUE,
                      name.treatment=&quot;intervention&quot;,
                      names.influencing.treatment=c(&quot;prognosis&quot;, &quot;clinic&quot;, &quot;age&quot;),
                      names.influencing.rule=c(&quot;age&quot;, paste0(&quot;gene_&quot;, 1:10)),
                      propensity.method=&quot;logistic.regression&quot;,
                      rule.method=&quot;glm.regression&quot;)
</code></pre>

<p>this has limited utility because it required us to specify just one value for the <code>prediction.approach</code> argument (even if we don&#39;t have <em>a priori</em> knowledge about which of split-regression, OWL framework, and direct-interactions approaches will perform best) and to specify just one regression method for the <code>propensity.score</code> and <code>rule.method</code> arguments (even if we are not sure whether standard logistic regression or lasso/ridge logistic regression will yield a better rule).</p>

<p>Instead, it would be more useful to perform model selection to estimate rules for different combinations of split-regression/OWL framework/direct-interactions and standard/lasso/ridge logistic regression (e.g. by looping over calls to <code>BuildRule()</code>). The model-selection process is automated in <code>CompareRulesOnValidation()</code>.</p>

<h2>On the Validation Dataset, Perform Model Selection</h2>

<p>Here we will perform model selection by calling <code>CompareRulesOnValidation()</code> with the arguments</p>

<pre><code class="r">vec.approaches=c(&quot;OWL&quot;, &quot;split.regression&quot;, &quot;OWL.framework&quot;, &quot;direct.interactions&quot;)
vec.rule.methods=c(&quot;glm.regression&quot;, &quot;lasso&quot;, &quot;ridge&quot;)
</code></pre>

<p>which are actually the default values of <code>CompareRulesOnValidation()</code>, and with</p>

<pre><code class="r">vec.propensity.methods=&quot;logistic.regression&quot;
</code></pre>

<p>Now we perform model selection by calling <code>CompareRulesOnValidation()</code></p>

<pre><code class="r">set.seed(123)
model.selection &lt;- CompareRulesOnValidation(development.data=development.data,
                validation.data=validation.data,
                study.design.development=&quot;observational&quot;,
                vec.approaches=c(&quot;split.regression&quot;, &quot;OWL.framework&quot;, &quot;direct.interactions&quot;),
                vec.rule.methods=c(&quot;glm.regression&quot;, &quot;lasso&quot;, &quot;ridge&quot;),
                vec.propensity.methods=&quot;logistic.regression&quot;,
                name.outcome.development=&quot;no_relapse&quot;,
                type.outcome.development=&quot;binary&quot;,
                name.treatment.development=&quot;intervention&quot;,
                names.influencing.treatment.development=c(&quot;prognosis&quot;, &quot;clinic&quot;, &quot;age&quot;),
                names.influencing.rule.development=c(&quot;age&quot;, paste0(&quot;gene_&quot;, 1:10)),
                desirable.outcome.development=TRUE)
</code></pre>

<p>We can compare these estimates for the nine treatment rules (three approaches, three combinations of rule/propensity methods) to decide which rules to bring forward to the evaluation dataset. For context, the estimates for the naive &ldquo;treat.all&rdquo; and &ldquo;treat.none&rdquo; strategies are always provided by <code>CompareRulesOnValidation()</code>.</p>

<p>First, for rules estimated with the split-regression approach, we obtain the estimates
\footnotesize</p>

<pre><code class="r">model.selection$list.summaries[[&quot;split.regression&quot;]] 
##                                                    Positives Negatives
## propensity_logistic.regression_rule_glm.regression       787       463
## propensity_logistic.regression_rule_lasso               1089       161
## propensity_logistic.regression_rule_ridge               1250         0
## treat.all                                               1250         0
## treat.none                                                 0      1250
##                                                    ATE in Positives
## propensity_logistic.regression_rule_glm.regression           0.1112
## propensity_logistic.regression_rule_lasso                    0.0600
## propensity_logistic.regression_rule_ridge                    0.0383
## treat.all                                                    0.0383
## treat.none                                                       NA
##                                                    ATE in Negatives
## propensity_logistic.regression_rule_glm.regression          -0.1053
## propensity_logistic.regression_rule_lasso                   -0.2576
## propensity_logistic.regression_rule_ridge                        NA
## treat.all                                                        NA
## treat.none                                                   0.0383
##                                                        ABR
## propensity_logistic.regression_rule_glm.regression  0.1090
## propensity_logistic.regression_rule_lasso           0.0855
## propensity_logistic.regression_rule_ridge           0.0383
## treat.all                                           0.0383
## treat.none                                         -0.0383
</code></pre>

<p>\normalsize
Next, for the OWL framework we have
\footnotesize</p>

<pre><code class="r">model.selection$list.summaries[[&quot;OWL.framework&quot;]] 
##                                                    Positives Negatives
## propensity_logistic.regression_rule_glm.regression       783       467
## propensity_logistic.regression_rule_lasso               1245         5
## propensity_logistic.regression_rule_ridge               1250         0
## treat.all                                               1250         0
## treat.none                                                 0      1250
##                                                    ATE in Positives
## propensity_logistic.regression_rule_glm.regression           0.1030
## propensity_logistic.regression_rule_lasso                    0.0408
## propensity_logistic.regression_rule_ridge                    0.0383
## treat.all                                                    0.0383
## treat.none                                                       NA
##                                                    ATE in Negatives
## propensity_logistic.regression_rule_glm.regression          -0.0964
## propensity_logistic.regression_rule_lasso                   -0.5689
## propensity_logistic.regression_rule_ridge                        NA
## treat.all                                                        NA
## treat.none                                                   0.0383
##                                                        ABR
## propensity_logistic.regression_rule_glm.regression  0.1005
## propensity_logistic.regression_rule_lasso           0.0429
## propensity_logistic.regression_rule_ridge           0.0383
## treat.all                                           0.0383
## treat.none                                         -0.0383
</code></pre>

<p>\normalsize
and, last, for the direct-interactions approach
\footnotesize</p>

<pre><code class="r">model.selection$list.summaries[[&quot;direct.interactions&quot;]] 
##                                                    Positives Negatives
## propensity_logistic.regression_rule_glm.regression       784       466
## propensity_logistic.regression_rule_lasso                852       398
## propensity_logistic.regression_rule_ridge               1250         0
## treat.all                                               1250         0
## treat.none                                                 0      1250
##                                                    ATE in Positives
## propensity_logistic.regression_rule_glm.regression           0.0973
## propensity_logistic.regression_rule_lasso                    0.1056
## propensity_logistic.regression_rule_ridge                    0.0383
## treat.all                                                    0.0383
## treat.none                                                       NA
##                                                    ATE in Negatives
## propensity_logistic.regression_rule_glm.regression          -0.0866
## propensity_logistic.regression_rule_lasso                   -0.1833
## propensity_logistic.regression_rule_ridge                        NA
## treat.all                                                        NA
## treat.none                                                   0.0383
##                                                        ABR
## propensity_logistic.regression_rule_glm.regression  0.0933
## propensity_logistic.regression_rule_lasso           0.1304
## propensity_logistic.regression_rule_ridge           0.0383
## treat.all                                           0.0383
## treat.none                                         -0.0383
</code></pre>

<p>\normalsize
Based on the above estimates in the validation set, we decide to select three rules to bring forward to the evaluation set: (1) split-regression with logistic/logistic as the propensity/rule methods,</p>

<pre><code class="r">model.selection$list.summaries$split.regression[&quot;propensity_logistic.regression_rule_glm.regression&quot;, ]
##        Positives        Negatives ATE in Positives ATE in Negatives 
##          787.000          463.000            0.111           -0.105 
##              ABR 
##            0.109
</code></pre>

<p>along with (2) OWL framework with logistic/logistic as the propensity/rule methods </p>

<pre><code class="r">model.selection$list.summaries$OWL.framework[&quot;propensity_logistic.regression_rule_glm.regression&quot;, ]
##        Positives        Negatives ATE in Positives ATE in Negatives 
##         783.0000         467.0000           0.1030          -0.0964 
##              ABR 
##           0.1005
</code></pre>

<p>and (3) direct-interactions with logistic/lasso as the propensity/rule methods.</p>

<pre><code class="r">model.selection$list.summaries$direct.interactions[&quot;propensity_logistic.regression_rule_lasso&quot;, ]
##        Positives        Negatives ATE in Positives ATE in Negatives 
##          852.000          398.000            0.106           -0.183 
##              ABR 
##            0.130
</code></pre>

<p>We can also see the underlying coefficient estimates for these rules with</p>

<pre><code class="r">rule.split &lt;- model.selection$list.rules$split.regression[[&quot;propensity_logistic.regression_rule_glm.regression&quot;]]
coef(rule.split$rule.object.control)
## (Intercept)         age      gene_1      gene_2      gene_3      gene_4 
##     0.38852     0.01230    -0.41212     0.04748    -0.09793    -0.12845 
##      gene_5      gene_6      gene_7      gene_8      gene_9     gene_10 
##    -0.04439    -0.13591    -0.24607     0.09746    -0.00498     0.05026
coef(rule.split$rule.object.treat)
## (Intercept)         age      gene_1      gene_2      gene_3      gene_4 
##    -0.20436    -0.00212     0.29588    -0.07918    -0.03679     0.01469 
##      gene_5      gene_6      gene_7      gene_8      gene_9     gene_10 
##     0.30874    -0.00162     0.02854    -0.04625     0.08332     0.08870
</code></pre>

<pre><code class="r">rule.OWL &lt;- model.selection$list.rules$OWL.framework[[&quot;propensity_logistic.regression_rule_glm.regression&quot;]]
coef(rule.OWL$rule.object)
## (Intercept)         age      gene_1      gene_2      gene_3      gene_4 
##    -0.21180    -0.00787     0.32037    -0.05444     0.02265     0.07921 
##      gene_5      gene_6      gene_7      gene_8      gene_9     gene_10 
##     0.15891     0.07133     0.11260    -0.07641     0.05433     0.01959
</code></pre>

<pre><code class="r">rule.DI &lt;- model.selection$list.rules$direct.interactions[[&quot;propensity_logistic.regression_rule_lasso&quot;]]
coef(rule.DI$rule.object)
## 13 x 1 sparse Matrix of class &quot;dgCMatrix&quot;
##                         1
## (Intercept)        .     
## treatment.neg.pos -0.0413
## age                .     
## gene_1             0.1277
## gene_2             .     
## gene_3             .     
## gene_4             .     
## gene_5             .     
## gene_6             .     
## gene_7             .     
## gene_8             .     
## gene_9             .     
## gene_10            .
</code></pre>

<h2>On the Evaluation Dataset, Evaluate the Selected Rules</h2>

<p>Since the validation dataset informed our model selection (i.e. we selected these particular two rules because they appeared best on the validation set), the estimates from the validation set itself are not trustworthy estimates of performance in independent settings. To obtain a trustworthy estimate of the rules&#39; performance in independent samples drawn from the same population, we turn to the <code>EvaluateRule()</code> function applied to the independent <strong>evaluation</strong> dataset.</p>

<p>First, we obtain the estimated performance of the rule using split-regression with</p>

<pre><code class="r">set.seed(123)
split.eval &lt;- EvaluateRule(evaluation.data=evaluation.data,
                           BuildRule.object=rule.split,
                           study.design=&quot;observational&quot;,
                           name.outcome=&quot;no_relapse&quot;,
                           type.outcome=&quot;binary&quot;,
                           desirable.outcome=TRUE,
                           name.treatment=&quot;intervention&quot;,
                           names.influencing.treatment=c(&quot;prognosis&quot;, &quot;clinic&quot;, &quot;age&quot;),
                           names.influencing.rule=c(&quot;age&quot;, paste0(&quot;gene_&quot;, 1:10)),
                           propensity.method=&quot;logistic.regression&quot;,
                           bootstrap.CI=FALSE)
split.eval$summaries
##                n.positives ATE.positives n.negatives ATE.negatives     ABR
## estimated.rule         772        0.0557         478       -0.1800  0.1032
## treat.all             1250       -0.0256           0            NA -0.0256
## treat.none               0            NA        1250       -0.0256  0.0256
</code></pre>

<p>And last, the rule from OWL framework yields the following estimates</p>

<pre><code class="r">set.seed(123)
OWL.eval &lt;- EvaluateRule(evaluation.data=evaluation.data,
                              BuildRule.object=rule.OWL,
                              study.design=&quot;observational&quot;,
                              name.outcome=&quot;no_relapse&quot;,
                              type.outcome=&quot;binary&quot;,
                              desirable.outcome=TRUE,
                              name.treatment=&quot;intervention&quot;,
                              names.influencing.treatment=c(&quot;prognosis&quot;, &quot;clinic&quot;, &quot;age&quot;),
                              names.influencing.rule=c(&quot;age&quot;, paste0(&quot;gene_&quot;, 1:10)),
                              propensity.method=&quot;logistic.regression&quot;,
                              bootstrap.CI=FALSE)
OWL.eval$summaries
##                n.positives ATE.positives n.negatives ATE.negatives     ABR
## estimated.rule         777        0.0521         473       -0.1756  0.0988
## treat.all             1250       -0.0256           0            NA -0.0256
## treat.none               0            NA        1250       -0.0256  0.0256
</code></pre>

<p>And last, the rule from OWL framework yields the following estimates</p>

<pre><code class="r">set.seed(123)
DI.eval &lt;- EvaluateRule(evaluation.data=evaluation.data,
                              BuildRule.object=rule.DI,
                              study.design=&quot;observational&quot;,
                              name.outcome=&quot;no_relapse&quot;,
                              type.outcome=&quot;binary&quot;,
                              desirable.outcome=TRUE,
                              name.treatment=&quot;intervention&quot;,
                              names.influencing.treatment=c(&quot;prognosis&quot;, &quot;clinic&quot;, &quot;age&quot;),
                              names.influencing.rule=c(&quot;age&quot;, paste0(&quot;gene_&quot;, 1:10)),
                              propensity.method=&quot;logistic.regression&quot;,
                              bootstrap.CI=FALSE)
DI.eval$summaries
##                n.positives ATE.positives n.negatives ATE.negatives     ABR
## estimated.rule         820        0.0326         430       -0.1563  0.0752
## treat.all             1250       -0.0256           0            NA -0.0256
## treat.none               0            NA        1250       -0.0256  0.0256
</code></pre>

<p>We could have also obtained bootstrap-based CIs for the ATE/ABR estimates (in both the validation and evaluation datasets) by specifying the following arguments to <code>BuildRulesOnValidation</code> and <code>EvaluateRule()</code></p>

<pre><code class="r">bootstrap.CI=TRUE
booststrap.CI.replications=1000 # or any other number of replications
</code></pre>

<p>but we chose not to compute CIs in this example to minimize run-time.</p>

<h3>References</h3>

<ul>
<li>Yingqi Zhao, Donglin Zeng, A. John Rush &amp; Michael R. Kosorok (2012). Estimating individualized treatment rules using outcome weighted learning. Journal of the American Statistical Association, 107:499 1106&ndash;1118.</li>
<li>Lu Tian, Ash A. Alizadeh, Andrew J. Gentles, Robert Tibshirani (2014). A simple method for estimating interactions between a treatment and a large number of covariates. Journal of the American Statistical Association, 109:508: 1517&ndash;1532.</li>
<li>Shuai Chen, Lu Tian, Tianxi Cai, Menggang Yu (2017). A general statistical framework for subgroup identification and comparative treatment scoring. Biometrics, 73:4: 1199&ndash;1209.</li>
<li>Jeremy Roth and Noah Simon (2019). Using propensity scores to develop and evaluate treatment rules with observational data. (Manuscript in progress).</li>
<li>Jeremy Roth and Noah Simon (2019). Elucidating outcome-weighted-learning and its comparison to split-regression: direct vs. indirect methods in practice. (Manuscript in progress).</li>
</ul>

</body>

</html>
